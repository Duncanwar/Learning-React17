"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEmptyValues = exports.getValuesForTable = exports.getEntries = exports.getReferenceTitle = void 0;
// Utils
const is_1 = require("../is");
const array_1 = require("../array");
function getReferenceTitle(entry, systemFields = ['id', 'createdAt', 'updatedAt', 'status', 'modelName']) {
    const entryFields = Object.entries(entry).filter((entryField) => !systemFields.includes(entryField[0]));
    let title = 'Unknown';
    if (entryFields.length > 0) {
        title = entryFields[0][1] || title; // eslint-disable-line prefer-destructuring
    }
    return title;
}
exports.getReferenceTitle = getReferenceTitle;
function getEntries(data, exclude = ['updatedAt']) {
    if (!data) {
        return null;
    }
    const { fields, values } = data;
    const systemHead = [];
    const systemBody = [];
    const head = [];
    const body = [];
    let entries = {};
    if (fields) {
        for (const field of fields) {
            if (!exclude.includes(field.identifier) && field.type !== 'Reference') {
                if (field.isSystem && field.identifier !== 'id') {
                    systemHead.push(field.fieldName);
                    systemBody.push(field.identifier);
                }
                else {
                    head.push(field.fieldName);
                    body.push(field.identifier);
                }
                if (!values) {
                    for (const value of field.values) {
                        entries[value.entry] = entries[value.entry] || {};
                        entries[value.entry][field.identifier] = value.value;
                    }
                }
                else {
                    entries = values;
                }
            }
        }
    }
    return {
        head,
        body,
        systemHead,
        systemBody,
        entries: Object.values(entries)
    };
}
exports.getEntries = getEntries;
function getValuesForTable(data, excludeMore, orderBy, direction, chunks) {
    if (!data) {
        return null;
    }
    direction = direction || 'asc';
    chunks = chunks || 10;
    const exclude = excludeMore || ['updatedAt'];
    const { head, body, entries: rows, systemHead, systemBody } = getEntries(data, exclude);
    if (orderBy) {
        if (direction === 'asc') {
            rows.sort((a, b) => (a[orderBy] > b[orderBy] ? 1 : -1));
        }
        else {
            rows.sort((a, b) => (a[orderBy] < b[orderBy] ? 1 : -1));
        }
    }
    return {
        head: head.concat(systemHead),
        body: body.concat(systemBody),
        rows: (0, array_1.chunk)(rows, chunks),
        raw: rows,
        total: rows.length
    };
}
exports.getValuesForTable = getValuesForTable;
function getEmptyValues(values, required = []) {
    const emptyValues = {};
    Object.keys(values).forEach((field) => {
        const v = (0, is_1.isString)(values[field]) ? values[field].trim() : values[field];
        if (required && required.length === 0 && (v === '' || v === null)) {
            emptyValues[field] = true;
        }
        else if (required && required.includes(field) && (v === '' || v === null)) {
            emptyValues[field] = true;
        }
    });
    return !(0, is_1.isEmptyObject)(emptyValues) ? emptyValues : false;
}
exports.getEmptyValues = getEmptyValues;
